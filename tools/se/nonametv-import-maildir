#!/usr/bin/perl -w

use strict;

use Mail::Box;
use Mail::Box::Manager;

use File::Temp qw/tempdir/;
use File::Basename;

use MIME::WordDecoder;
use Getopt::Long;

my %opt = ( manual => 0,
            test => 0,
            );

my $res = GetOptions( \%opt, qw/manual test/ );

if( not $res )
{
  print << 'EOHELP';
nonametv-import-maildir [--manual] [--test]

Import data into the database. Data is fetched from files attached to
messages in a maildir.

  --manual  Ask the user which Importer to use if the information
            cannot be derived from the message. 

  --test    Run the importer in test-mode.

EOHELP

  exit 1;
}


# Flag messages AFTER they have been processed. Then I normally
# only have to move the message to the correct folder.

my $tmpdir = tempdir( CLEANUP => 1 );

### Get a word-decoder which maps to ISO-8859-1 (Latin1):
my $wd = supported MIME::WordDecoder "ISO-8859-1";

my $mgr = Mail::Box::Manager->new;
my $folder = $mgr->open( "/home/mattias/Maildir/.Projects.xmltv-data/", 
                         access => 'rw',
                         extract => 'ALWAYS' );

foreach my $message ($folder->messages)
{
  next if $message->isDeleted();
  next if $message->label( 'flagged' );
  next unless $message->isMultipart;

  my $subject = $wd->decode( $message->get( 'Subject' ) ) || '';
  my $from = $message->get( 'From' );

  my $importer = guess_importer( $from, $subject );

  if( not defined( $importer ) )
  {
    if( $opt{manual} )
    {
      $importer = "manual";
    }
    else
    {
      next;
    }
  }

  if( process_parts( $message, $importer ) )
  {
    $message->label( 'flagged' => 1 );
  }
}

$mgr->closeAllFolders;
 
sub process_parts
{
  my( $part, $importer ) = @_;

  my $type = $part->get('Content-Type');
  return 0 if $type eq "text/plain";

  if($part->isMultipart)
  {
    my $count = 0;
    foreach my $child ($part->parts)
    {
      $count += process_parts( $child, $importer );
    }
    return $count;
  }
  else
  {
    my $disp = $part->body->disposition;
    my $name = $disp->attribute('filename') 
      || $disp->attribute('name') 
      || 'noname';

    if( $importer eq "manual" )
    {
      print "$name: ";
      $importer = <STDIN>;
      $importer =~ tr/\n\r //d;
      return 0 if $importer eq "";

      if( $importer eq "save" )
      {
        # a major security hole if you accept any path!
        my $filename = "/tmp/" . basename( $name );
        
        open(FH, "> $filename");
        $part->decoded->print(\*FH);
        close(FH);

        print "Wrote $filename\n";
        return 1;
      }
        
    }
    
#    print "  $importer $name $type " . $part->size . "\n";
    
    # a major security hole if you accept any path!
    my $filename = "$tmpdir/" . basename( $name );
  
    open(FH, "> $filename");
    $part->decoded->print(\*FH);
    close(FH);

    my $command = "perl -I lib tools/nonametv-import";
    my $args = join " ", @ARGV;

    if( $opt{test} )
    {
      print qx%$command test $importer "$filename" $args 2>&1%;
    }
    else
    {
      print qx%$command $importer "$filename" $args 2>&1%;
    }
    unlink( $filename );
  }

  return $opt{test} ? 0 : 1;
}

sub guess_importer
{
  my( $from, $subject ) = @_;

  return "Expressen" if $from =~ /expressen.se/;
  return "Discovery" if $from =~ /text100.(se)|(com)/;

  return undef;
}
